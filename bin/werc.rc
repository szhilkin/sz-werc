#!/usr/local/plan9/bin/rc
. ./cgilib.rc
cd ..

forbidden_uri_chars='[^a-zA-Z0-9_+\-\/\.]'
response_format=html

fn get_lib_file {
    if(test -f $sitedir/_werc/lib/$1)
    	echo -n $sitedir/_werc/lib/$1
    if not if(! ~ $#masterSite 0 && test -f $sitesdir/$masterSite/_werc/lib/$1)
    	echo -n $sitesdir/$masterSite/_werc/lib/$1
    if not if(test -f lib/$1)
    	echo -n lib/$1
}

# Title
fn gentitle {
    echo '<h1 class="headerTitle"><a href="/">' ^ $"siteTitle ^ ' <span id="headerSubTitle">' ^ $"siteSubTitle ^ '</span></a></h1>'
}

# Don't change var name or trailing ';', dirfilter might be changed from _werc/config!
# ls -F style input of the form: $sitedir/path/to/files/
#          <ls -F+x><symlink hack><Useless?><hiden files  >
dirfilter='s/\*$//; s,/+\./+,/,g; s,^\./,,; /\/[._][^\/]/d; /'^$forbidden_uri_chars^'/d; /^\/(robots|sitemap)\.txt$|\/index\.(md|html|txt|tpl)$/d; /_werc\/?$/d; '
dirclean=' s/\.(md|html|txt)$//; '

# To be used from config files
fn hide_paths {
    for(i in $*)
       dirfilter=$dirfilter^'/^'$i'$/d; '
}

# Sidebar 
fn gensidebar {
    # Ignore stderr, last path element might be a file that doesn't exist (eg., foo for foo.md)
    # /./ to deal with p9p's ls failure to follow dir symlinks otherwise
    ls -F $sitedir/./$req_paths_list >[2]/dev/null \
        | sed 's!^'$sitedir'!!; '^$dirfilter^'/\/[^_.\/][^\/]*(\.(md|txt|html)|\/)$/!d; '^$dirclean \
        | sort -u | awk -F/ ' 
    function p(x, y, s) { for(i=0; i < x-y; i+=1) print s }
    { 
        d = ""
        if(match($0, "/$"))
            d = "/"
        sub("/$", "") # Strip trailing / for dirs so NF is consistent 

        p(NF, lNF, "<ul class=\"side-bar\">")
        p(lNF, NF, "</ul>")
        lNF = NF

        bname = $NF d
        path = $0 d
        gsub("_", " ", bname)

        if(index(ENVIRON["req_path"] "/", path) == 1)
            print "<li><a href=\"" path "\" class=\"thisPage\">&raquo;<i> " bname "</i></a>"
        else 
            print "<li><a href=\"" path "\">&rsaquo; " bname "</a></li>"
    }
    END { p(lNF, 0, "</ul>") }'
}


# Handlers
fn set_handler { handler=$* }

fn md_handler { cat $* | $formatter }

fn tpl_handler { template $1 }

fn html_handler {
    # body states: 0 = no <body> found, 2 = after <body>, 1 = after <body></body>, -1 = after </body>
    awk 'gsub(".*<[Bb][Oo][Dd][Yy][^>]*>", "") > 0 {body=2}
        gsub("</ *[Bb][Oo][Dd][Yy][^>]*>.*", "") > 0 {print; body=body-1}
        body==2 {print}
        body==0 {buf=buf "\n" $0}
        END {if(body<=0) {print buf}}' < $1
}

fn txt_handler {
    # Note: Words are not broken, even if they are way beyond 82 chars long
    echo '<pre>' `{ sed 's/</\&lt;/g; s/>/\&gt;/g' < $1 | fmt -l 82 -j } '</pre>'
}

fn dir_listing_handler {
    d=`{basename -d $1}
    echo $d|sed 's,.*//,,g; s,/$,,; s,/, / ,g; s,.*,<h1 class="dir-list-head">&</h1> <ul class="dir-list">,'
    # Symlinks suck: '/.' forces ls to list the linked dir if $d is a symlink.
    ls -F $d/. | sed $dirfilter$dirclean' s,.*/([^/]+/?)$,<li><a href="\1">\1</a></li>,'
    echo '</ul>'
}

fn select_handler {

    if(test -f $local_path.md) {
        set_handler md_handler $local_path.md
        if(! ~ $#allowComments 0 && ~ $REQUEST_METHOD POST) {
            get_post_args comment_text
            d=`{date -n} # FIXME Obvious race
            d=$local_path.md_werc/comments/$d/

            u=$logged_user
            if(~ $#logged_user 0) {
                get_post_args comment_user_name comment_user_password
                # TODO Should take this path too if the user can login but doesn't
                # belong to required group
                if(! login_user $comment_user_name $comment_user_password) {
                    u=$comment_user_name ':' $comment_user_password
                    d=$d^'_pending'
                }
                if not
                    u = $logged_user
            }

            umask 002
            mkdir -m 775 -p $d
            echo $u > $d/user
            echo $comment_text > $d/body
        }
    }
    if not if(test -f $local_path.tpl)
        set_handler tpl_handler $local_path.tpl

    if not if(test -f $local_path.html)
        set_handler html_handler $local_path.html

    # Explicit .html urls, unfortunately usually the web server will handle this as static files
    if not if(~ $local_path *.html && test -f $local_path)
        perm_redirect `{ echo $req_path|sed 's/.html$//' }

    # Global tpl (eg sitemap.tpl)
    if not if(test -f lib^$req_path^.tpl)
        set_handler tpl_handler lib^$req_path^.tpl

    if not if(test -f $local_path.txt)
        set_handler txt_handler $local_path.txt

    # Apps
    if not if(! ~ $#enabled_apps 0 && select_apps)
        set_handler app_handler

    # Dir listing
    if not if(~ $local_path */index)
        set_handler dir_listing_handler $local_path

    # File not found
    if not {
        set_handler tpl_handler `{get_lib_file 404.tpl}
        dprint 'NOT FOUND: '$SERVER_NAME^$"REQUEST_URI^' - '^$"HTTP_REFERER^' - '^$"HTTP_USER_AGENT
        echo 'Status: 404 Not Found'
    }

}

fn genbody { $handler(1) $handler(2-) }

# Careful, the proper p9p path might not be set until initrc.local is sourced
path=(. $PLAN9/bin ./bin/ /bin/ /usr/bin) 

headers=lib/headers.tpl
master_template=default_master.tpl
sidebar=sidebar
werc_root=`{pwd}
for(i in siteTitle siteSubTitle pageTitle extraHeaders)
    $i = ''

# TODO: Per-req variables should move after initrc loading.
site=$SERVER_NAME
base_url=http://$site/
sitesdir=sites
sitedir=$sitesdir/$site
current_date_time=`{date}

. ./etc/initrc

if(test -f etc/initrc.local)
    . ./etc/initrc.local

# Parse request URL
# NOTE: $REQUEST_URI is not officially in CGI 1.1, but seems to be de-facto
req_path=`{echo -n $REQUEST_URI | sed 's/\?.*//; s/'^$forbidden_uri_chars^'//g; s/\.\.*/./g; 1q'}
local_path=$sitedir$req_path
ifs='/' { args=`{echo -n $req_path} }

# Hack: preload post data so we can access it from templates where cgi's stdin is not accesible
if(~ $REQUEST_METHOD POST) {
    get_post_args 
    login_user
}

if(! ~ $#args 0)
    pageTitle=`{ echo $args|sed -e 's/ / - /g' -e 's/_/ /g' }

if(~ $req_path */index)
    perm_redirect `{echo $req_path | sed 's,/index$,/,'}

if(~ $local_path */)
    local_path=$local_path^'index'
if not if(test -d $local_path)
    perm_redirect $req_path^'/'

p=()
cd $sitedir
if(test -f _werc/config)
    . _werc/config
for(i in ('' $args)) {
    p=($"p^/^$i)
    req_paths_list=($req_paths_list $p)
    if(test -d $i) {
        cd $i
        if(test -f _werc/config)
            . _werc/config
    }
}
cd $werc_root

# Redirections and other preprocessing
if(~ $#redirectPermanent 1) {
    perm_redirect $"redirectPermanent
}
if not if(~ $#redirectPermanent 2) {
    from='http://'^$SERVER_NAME^$req_path
    to=`{echo $from|sed 's@'^$redirectPermanent(1)^'@'^$redirectPermanent(2)^'@'}
    if(! ~ $to $from)
        perm_redirect $to
}

# Set Page title
if(~ $pageTitle '')
	pageTitle=$siteTitle^' '^$siteSubTitle
if not
	pageTitle=$"pageTitle^' | '^$"siteTitle^' '^$"siteSubTitle

select_handler

if(! ~ $#debug 0)
    dprint '  '$"SERVER_NAME^$"REQUEST_URI' - '$"HTTP_USER_AGENT' - '$"REQUEST_METHOD' - '$"handler

# Template/body selection
master_template=`{get_lib_file $master_template}

if(~ $response_format html) {
    # Is awk_buffer really useful?
	template $headers $master_template | awk_buffer
	echo '</body></html>'
}
if not if(~ $response_format raw)
	template < $master_template 
