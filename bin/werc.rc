#!/usr/local/plan9/bin/rc
. ./cgilib.rc
cd ..

forbidden_uri_chars='[^a-zA-Z0-9_+\-\/\.]'

# Expected input: ls -F style, $sitedir/path/to/files/
#          <ls -F+x><symlink hack><Useless?><hiden files  >
dirfilter='s/\*$//; s,/+\./+,/,g; s,^\./,,; /\/[._][^\/]/d; /'^$forbidden_uri_chars^'/d; /^\/(robots|sitemap)\.txt$|\/index\.(md|html|txt|tpl)$/d; /_werc\/?$/d; '
dirclean=' s/\.(md|html|txt)$//; '

# To be used from config files
fn hide_paths {
    for(i in $*)
       dirfilter=$dirfilter^'/^'$i'$/d; '
}

# Sidebar 
fn nav_tree {
    if(! ~ $#sideBarNavTitle 0)
        echo '<p class="sideBarTitle">'$"sideBarNavTitle':</p>'
    # Ignore stderr, last path element might be a file that doesn't exist (eg., foo for foo.md)
    # /./ to deal with p9p's ls failure to follow dir symlinks otherwise
    ls -F $sitedir/./$req_paths_list >[2]/dev/null \
        | sed 's!^'$sitedir'!!; '^$dirfilter^'/\/[^_.\/][^\/]*(\.(md|txt|html)|\/)$/!d; '^$dirclean \
        | sort -u | awk -F/ ' 
    function p(x, y, s) { for(i=0; i < x-y; i+=1) print s }
    { 
        d = ""
        if(match($0, "/$"))
            d = "/"
        sub("/$", "") # Strip trailing / for dirs so NF is consistent 

        p(NF, lNF, "<ul class=\"side-bar\">")
        p(lNF, NF, "</ul>")
        lNF = NF

        bname = $NF d
        path = $0 d
        gsub("_", " ", bname)

        if(index(ENVIRON["req_path"] "/", path) == 1)
            print "<li><a href=\"" path "\" class=\"thisPage\">&raquo;<i> " bname "</i></a>"
        else 
            print "<li><a href=\"" path "\">&rsaquo; " bname "</a></li>"
    }
    END { p(lNF, 0, "</ul>") }'
}


# Handlers
fn md_handler { $formatter < $1 }

fn tpl_handler { template $* }

fn html_handler {
    # body states: 0 = no <body> found, 2 = after <body>, 1 = after <body></body>, -1 = after </body>
    awk 'gsub(".*<[Bb][Oo][Dd][Yy][^>]*>", "") > 0 {body=2}
        gsub("</ *[Bb][Oo][Dd][Yy][^>]*>.*", "") > 0 {print; body=body-1}
        body==2 {print}
        body==0 {buf=buf "\n" $0}
        END {if(body<=0) {print buf}}' < $1
}

fn txt_handler {
    # Note: Words are not broken, even if they are way beyond 82 chars long
    echo '<pre>' `{ sed 's/</\&lt;/g; s/>/\&gt;/g' < $1 | fmt -l 82 -j } '</pre>'
}

fn dir_listing_handler {
    d=`{basename -d $1}
    echo $d|sed 's,.*//,,g; s,/$,,; s,/, / ,g; s,.*,<h1 class="dir-list-head">&</h1> <ul class="dir-list">,'
    # Symlinks suck: '/.' forces ls to list the linked dir if $d is a symlink.
    ls -F $dir_listing_ls_opts $sitedir$d/. | sed $dirfilter$dirclean' s,.*/([^/]+/?)$,<li><a href="\1">\1</a></li>,'
    echo '</ul>'
}

fn setup_handlers {

    if(test -f $local_path.md)
        handler_body_main=(md_handler $local_path.md)
    if not if(test -f $local_path.tpl)
        handler_body_main=(tpl_handler $local_path.tpl)
    if not if(test -f $local_path.html)
        handler_body_main=(html_handler $local_path.html)
    # Global tpl (eg sitemap.tpl), should take precedence over txt handler!
    if not if(test -f lib^$req_path^.tpl)
        handler_body_main=(tpl_handler lib^$req_path^.tpl)
    if not if(test -f $local_path.txt)
        handler_body_main=(txt_handler $local_path.txt)

    # XXX Should check that $enabled_apps exist in $werc_apps?
    # XXX Should split init of apps that provide main handler (eg., blog) and apps that don't (eg., comments)?
    if(! ~ $#enabled_apps 0)
        for(a in $enabled_apps)
            $a^'_init'

    if(! ~ $#handler_body_main 0)
        { } # We are done
    # Dir listing
    if not if(~ $local_path */index)
        handler_body_main=(dir_listing_handler $req_path)
    # Canonize explicit .html urls, the web server might handle this first!
    if not if(~ $local_path *.html && test -f $local_path)
        perm_redirect `{ echo $req_path|sed 's/.html$//' }
    # Fallback static file handler
    if not if(test -f $local_path)
        static_file $local_path
    if not if(~ $req_path /pub/* && test -f .$req_path)
        static_file .$req_path
    # File not found
    if not {
        handler_body_main=(tpl_handler `{get_lib_file 404.tpl})
        echo 'Status: 404 Not Found'
        dprint 'NOT FOUND: '$SERVER_NAME^$"REQUEST_URI^' - '^$"HTTP_REFERER^' - '^$"HTTP_USER_AGENT
    }
}

fn run_handlers { for(h in $*) run_handler $$h }
fn run_handler { $*(1) $*(2-) }

# Careful, the proper p9p path might not be set until initrc.local is sourced
path=(. $PLAN9/bin ./bin/ /bin/ /usr/bin) 

headers=lib/headers.tpl
res_tail='</body></html>'
ll_add handlers_bar_left nav_tree
werc_apps=( apps/* )
werc_root=`{pwd}
sitesdir=sites
for(i in siteTitle siteSubTitle pageTitle extraHeaders)
    $i = ''

# TODO: Per-req variables should move after initrc loading.
site=$SERVER_NAME
base_url=http://$site/
sitedir=$sitesdir/$site
master_template=`{get_lib_file default_master.tpl}
current_date_time=`{date}

. ./etc/initrc

if(test -f etc/initrc.local)
    . ./etc/initrc.local

for(a in $werc_apps)
    . ./$a/app.rc

# Parse request URL
# NOTE: $REQUEST_URI is not officially in CGI 1.1, but seems to be de-facto
req_path=`{echo -n $REQUEST_URI | sed 's/\?.*//; s/'^$forbidden_uri_chars^'//g; s/\.\.*/./g; 1q'}
local_path=$sitedir$req_path
ifs='/' { args=`{echo -n $req_path} }

# Hack: preload post data so we can access it from templates where cgi's stdin is not accesible
if(~ $REQUEST_METHOD POST) {
    load_post_args
    login_user
}

if(! ~ $#args 0)
    pageTitle=`{ echo $args|sed -e 's/ / - /g' -e 's/_/ /g' }

if(~ $req_path */index)
    perm_redirect `{echo $req_path | sed 's,/index$,/,'}

if(~ $local_path */) {
    if(test -d $local_path)
        local_path=$local_path^'index'
    if not # XXX: This redir might step on apps with synthetic dirs.
        perm_redirect `{echo $req_path|sed 's,/+$,,'}
}
if not if(test -d $local_path)
    perm_redirect $req_path^'/'

cd $sitedir
req_paths_list='/' # Note: req_paths_list doesn't include 'stnythetic' dirs.
conf_wd='/' # Used in config files to know where we are in the document tree.
if(test -f _werc/config)
    . _werc/config
for(i in $args) {
    conf_wd=$conf_wd^$i
    req_paths_list=($req_paths_list $conf_wd)
    if(test -d $i) {
        conf_wd=$conf_wd^'/'
        cd $i
        if(test -f _werc/config)
            . _werc/config
    }
}
cd $werc_root

# Redirections and other preprocessing
if(~ $#redirectPermanent 1) {
    perm_redirect $"redirectPermanent
}
if not if(~ $#redirectPermanent 2) {
    from='http://'^$SERVER_NAME^$req_path
    to=`{echo $from|sed 's@'^$redirectPermanent(1)^'@'^$redirectPermanent(2)^'@'}
    if(! ~ $to $from)
        perm_redirect $to
}

# Set Page title
if(~ $pageTitle '')
    pageTitle=$siteTitle^' '^$siteSubTitle
if not
    pageTitle=$"pageTitle^' | '^$"siteTitle^' '^$"siteSubTitle

setup_handlers

if(! ~ $#debug 0)
    dprint '  '$"SERVER_NAME^$"REQUEST_URI' - '$"HTTP_USER_AGENT' - '$"REQUEST_METHOD' - '$"handler_body_main - $"master_template

template $headers $master_template | awk_buffer
echo $res_tail
